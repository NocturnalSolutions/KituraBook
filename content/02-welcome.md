# Foreword: Welcome to Kitura!

2019 marks thirty years since Tim Berners-Lee began development on what would become the World Wide Web. His combination of HTML, an easy-to-write markup language for creating interactive page-like documents which could link to other documents in a natural way; HTTP, a flexible yet easy-to-implement transfer protocol for files; and a web browser, an easy-to-use software program which made finding and viewing documents on the network much simpler to do than could be done with other existing internet services at the time took over the world as it made both accessing and publishing to the internet well within the reach of those that its difficulty previously excluded.

Thirty years later, the web has grown in ways that it’s hard to imagine Sir Berners-Lee could have predicted. The derivatives of his inventions are used today to allow people to connect and communicate for both business and personal reasons and empowers businesses to contribute trillions of dollars each year to the global economy.

In 2014, Apple, riding high from the success of its iPhone product, introduced a new programming language called Swift to the world. Swift was developed internally in Apple to replace the aging, quirky Objective-C language which was the standard language used to build native applications for Apple’s platforms at the time, which were centered around a framework called Cocoa. Swift turned out to be a big hit among Cocoa developers, as its modern syntax and features made Objective-C look like the clumsy hack it started out as in comparison. Apple promised that it intended to release the language’s toolset as open-source software which could be used on non-Cocoa platforms, and in late 2015, it delivered on that promise. Almost immediately, people started trying to find ways to use this open-sourced Swift to write software to serve documents on the web.

One of the entities working on this was IBM, a company that Apple would have called a rival back when Berners-Lee was first starting his project. IBM took an interest in what would come to be known as “server-side Swift” as a replacement for Java in the services it provides to clients. As part of this, a Swift-based web framework called Kitura was released in early 2016 as open-source software under the liberal [Apache 2.0 license](https://tldrlegal.com/license/apache-license-2.0-%28apache-2.0%29#summary) (the same as Swift itself) and has maintained it since.

## Why Server-Side Swift?

When it comes to choosing programming languages and frameworks with which to build a web-facing application, us developers have an embarrassment of riches. Between Python with Django or Flask, Ruby with Rails or Sinatra, C# with Nancy, Java with GWT, Struts, or Spring, Perl with Mojolicious or Catalyst, JavaScript with Node.JS, or big dog PHP with Laravel, WordPress, CodeIgniter, Drupal, Joomla, Symfony, Zend, Yii, or Cake, or hundreds of other languages and frameworks already out there, do we really need Swift on the server?

One big advantage Swift brings to the server is the language itself. Swift’s success in the Cocoa ecosystem and particularly with iOS devices means there’s a good-sized chunk of people out there who are building applications with Swift that quite likely need to integrate with a server-side application. Server-side Swift means they can leverage their existing Swift skills to build that application rather than having to use another language they may be far less familiar with. (Writing cross-platform applications with Swift follows somewhat of a different procedure than writing Cocoa applications, however; have a look at this book’s “[Cross-Platform Swift for Cocoa Developers](appendices/a-savvy-devs.md)” appendix if this applies to you.)

Another obvious advantage is that Swift is a compiled language, whereas most of those listed above are interpreted. This means that, absent optional pre-compilers and caches for those languages, web applications written with Swift can be much faster and memory-efficient than those written with the other languages, and also avoid security risks that can come with interpreted languages.

One current major disadvantage to Swift is its platform support. Apple currently releases Swift packages for two operating systems; macOS and Ubuntu Linux. That’s it. If you want to use Swift on any other platform, you will have to use unofficial packages which may be out of date, of unknown quality, or missing important frameworks or subsystems such as Swift Package Manager. In some cases, these packages may not exist at all, in which case you’ll have to compile Swift’s toolchain yourself. I don’t know about you, but that doesn’t sound like my idea of fun. (IBM themselves have ported Swift to their big-iron-oriented z/OS and Power Linux operating systems; I haven’t used them, but given IBM’s commitment to Swift, it’s fair to assume these projects are of high quality and capable of running Kitura.) I personally hope that Apple will offer Swift for other Linuxes, BSDs, and especially Windows in the near future, but so far that doesn’t appear to be a priority for them.

## Why Kitura?

There are other Swift-based web frameworks out there. By some accounts, the most popular is [Vapor](http://vapor.codes), another framework which was released shortly after Swift became open source and has undergone a good amount of development since then. [Perfect](https://www.perfect.org/index.html) is another popular choice which has official documentation in both English and simplified Chinese, making it more accessible to China’s massive base of developers.

But this book is about my preferred framework, Kitura. One of the reasons I prefer Kitura is that it’s very easy and well-documented how to start a new project “from scratch,” whereas Vapor and Perfect both assume you will install a separate tool to generate “template” projects, full of a bunch of pre-written code, for you. (Truth be told, Kitura also has one of these tools [available](https://www.kitura.io/guides/kituracli/gettingstarted.html), but we will not be using it in this book.) I feel the IBM brand name also carries a lot of cachet and means that Kitura will probably be around and well-supported by IBM for a long time. But as both Perfect and Vapor are open-source projects, just as Kitura is, feel free to experiment with those as well and choose the one that fits you best if you’re not committed to using only Kitura yet.

## Prerequisite Knowledge

This book is not intended as an introduction to Swift or to the concepts of web development more broadly. Particularly, it is expected that you will have at least some knowledge of the following:

* **Swift:** You should already have Swift installed on your development system and understand how to write and compile at least basic applications with it. If you haven’t already, follow the [instructions on the official Swift site](https://swift.org/getting-started/) to install Swift. As for learning to write Swift code, there are countless resources available; as someone familiar with many other languages, the free [The Swift Programming Language](https://swift.org/documentation/) book was sufficient for me, but you can find other books and resources at various other sites and bookstores around the web and in real life. That being said, as existing web developers who may not be fully familiar with Swift are part of the target audience of this book, so the book will occasionally review quirky or unique parts of Swift that will be encountered when creating Kitura projects that might surprise those coming from other languages.
* **HTTP:** You should understand the basics of how HTTP works, including understanding the concepts of request and response headers, response codes such as 404 Not Found, and form encoding.
* **HTML:** Later chapters in this book will cover using a template engine to create HTML documents. A familiarity with properly-structured HTML 5 is assumed.
* **Relational databases:** Later chapters in this book will cover Kuery, IBM’s database integration framework for SQL-based databases. We will specifically be using its SQLite integration, but familiarity with making CRUD queries to any SQL-based database will be required.
* **Swift Package Manager and Git:** SPM will be used to compose projects from libraries such as Kuery and Kitura itself. If you’re new to SPM, check out the [Swift Package Manager Basics](appendices/b-spm.md) appendix for a quick introduction. Earlier chapters in this book will walk you through adding Kitura to your project with SPM, but later ones will assume you’re familiar enough with it to turn instructions like “Add library X to your project with SPM” into action. SPM uses Git for retrieving and managing versions of packages, so understanding Git and general version control concepts like tags and branches will be helpful to understanding SPM; that said, this book will not instruct you to use Git directly.

## Notably Absent Topics

After finishing this book, you will be able to write a web application which accepts many types of requests, from simple GET requests and form-encoded POST requests to more unusual PUT or DELETE requests; query SQL-based databases; and respond with JSON, XML, or HTML bodies with custom headers if needed. Generally speaking, this will be all you need to implement many types of web sites or services, or at least get started on implementing them.

That being said, there are some topics related to Kitura this book will *not* cover. Some are listed below, along with justification why they are not covered and links to where you can find more information on them if you’re so inclined.

* **`kitura create`:** As mentioned above, you can install a [command-line tool](https://www.kitura.io/guides/kituracli/gettingstarted.html) which will create a “starter” Kitura project with placeholder code. However, you will probably eventually want to delete some or all of that placeholder code when developing a project you want to release. To avoid this, to ensure each line of your Kitura project has a place and you understand what it does, and because starting a new Kitura project from scratch really isn’t that difficult, I will not be covering the usage of this tool in this book, and generally suggest you avoid using it.
* **Swift-Kuery-ORM:** Later chapters in this book will instruct you on using IBM’s Kuery database framework to connect your project with a database. IBM also built an ORM framework which abstracts the process of inserting and retrieving objects of the database. I will not be covering Swift-Kuery-ORM in this book, however. Part of this is a matter of personal taste, as I am more used to querying databases directly than using ORMs; part of the reason is that Swift-Kuery-ORM is somewhat incomplete compared to ORMs for other frameworks and those that have tried to use it have occasionally talked about hitting walls with what it allows you to do, where they have to “fall back” to Kuery in order to do what they need to do anyway. That said, if you’re unlike me and are more familiar with working with ORMs than without them, feel free to [give Swift-Kuery-ORM a look](https://github.com/IBM-Swift/Swift-Kuery-ORM).
* **Deployment:** There are a couple different ways to deploy a finished Kitura project to the world at large. The simplest way is to just build it as a release, take the resulting binary, and running it, perhaps proxying it through a traditional web server daemon like Nginx configured to handle the static files (this is how I run [Wastebin](http://wastebin.nocturnal.solutions)). Of course, IBM would prefer you to use their [Bluemix](https://console.bluemix.net/docs/runtimes/swift/getting-started.html#getting-started-tutorial) cloud hosting service. If you’re a fan of “container culture,” re-evaluate the poor choices you’ve made in life which have led you to this error; if you insist on living your life of insanity, you can use [Docker](https://github.com/apple/swift-docker) and Kubernetes and all of that nonsense to deploy as well. Once you’re ready to deploy, pick your preferred method and do more research on your end, as we won’t be covering it in this book.

## Getting More Help

You are not alone. As you go along, if you get stumped by something, don’t hesitate to reach out for help and clarification.

The Swift@IBM team site has a [public Slack instance](http://swift-at-ibm-slack.mybluemix.net/). (Slack is a feature-rich yet resource-intensive chat application targeted towards teams and workgroups.) There are several channels including #kitura specifically for Kitura discussion and #general which is good for general discussion about Swift development and other topics in the ecosystem. You can find me there under the username “nocturnal.” Feel free to reach out to me if you’re having any trouble with something in this book.

If Slack’s not your thing, you can also join the [Freenode IRC network](https://freenode.net). It doesn’t have any Kitura-specific channels currently (unfortunately), but it does have the #swift-lang channel which is great for general Swift discussion; there’s lots of smart people there. There may be other Swift-related channels in the IRC universe, but I like the Freenode network because its focus on open-source software means that if you need help with any other open-source (and some not-so-open-source) software you use throughout the day, you can probably find a channel related to it on Freenode. If you’re a Cocoa developer, the #iphonedev and/or #macdev channels may also be of interest; #iphonedev-chat is a fun channel for off-topic banter with others in the community. On Freenode, you can find me using the “_Nocturnal” alias. Again, feel free to reach out and say hi!

The [official Swift forums](https://forums.swift.org/) have a [Kitura category](https://forums.swift.org/c/related-projects/kitura). The category hasn’t seen much activity; also, I find the forum system that they are using, Discourse, to be quite confusing and borderline unusable. Nonetheless, forums are often a better place to ask long-form questions than the chat-based systems listed above.

If you want to reach out to me directly, you can email me at [contact@nocturnal.solutions](mailto:contact@nocturnal.solutions). That said, if you have technical questions about Swift or Kitura, I’d prefer if you used one of the methods above to ask them, as it means others can see the question and answer, which may help them as well - or so that others smarter than me can correct errors in the response I give you!

Finally, don’t forget about the GitHub issue queues on most projects hosted there. They’re generally intended for reporting bugs and such, but you’re generally welcome to ask for help with usage there too.

